#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
QCDS ‚Äì end-to-end demo med:
  ‚Ä¢ AER-massk√∂rning √∂ver BRCA2-regionen (GRCh37/GRCh38)
  ‚Ä¢ IBM-l√§ge (begr√§nsad m√§ngd varianter men ut√∂kningsbart)
  ‚Ä¢ 2-qubit-kontroller (TG/AC/CE) + 4-lager QCDS
  ‚Ä¢ Adaptiv Grover + ‚Äúroterande bitexkludering‚Äù (orakel per variant)
  ‚Ä¢ Sampler-shim (klarar olika Qiskit-versioner)
  ‚Ä¢ Lekmannaf√∂rklaringar (svenska) kan sl√•s p√• med --layman
  ‚Ä¢ En och samma v√§xel f√∂r kvantdator/emu (AER): --mode [aer|ibm],
    och flaggan --force-aer-4l f√∂r att k√∂ra 4L p√• emulator √§ven i IBM-l√§ge.

K√∂r-exempel:
  python qcds_full_gpt_10.py --mode aer --genome GRCh38 --layman
  python qcds_full_gpt_10.py --mode ibm --ibm-backend ibm_brisbane --ibm-max-variants 5 --layman
  python qcds_full_gpt_10.py --mode ibm --force-aer-4l --layman
"""

from __future__ import annotations
import argparse
import json
import math
import os
import random
import sys
import time
from dataclasses import dataclass
from typing import Dict, List, Optional, Tuple

# ---------------------------
# Qiskit-importer + robust "Sampler"-shim
# ---------------------------
BACKEND_FLAVOUR = "unknown"
try:
    # Qiskit Terra >= 0.25 med primitives
    from qiskit import QuantumCircuit, transpile
    from qiskit.quantum_info import Statevector
    try:
        from qiskit_aer import Aer
        BACKEND_FLAVOUR = "aer"
    except Exception:
        from qiskit import BasicAer as Aer  # fallback
        BACKEND_FLAVOUR = "basic-aer"
except Exception as e:
    print("‚ùå Kunde inte importera Qiskit-k√§rna:", e)
    sys.exit(1)

# F√∂r IBM-l√§ge (valfritt): vi f√∂rs√∂ker, men faller tillbaka snyggt.
HAVE_RUNTIME = False
try:
    from qiskit_ibm_runtime import QiskitRuntimeService
    HAVE_RUNTIME = True
except Exception:
    HAVE_RUNTIME = False


# --------- NYTT: robust backend-namn ----------
def backend_label(backend) -> str:
    """
    Returnera ett l√§sbart backend-namn oavsett Qiskit-version:
    - backend.name -> om str√§ng
    - backend.name() -> om metod
    - backend.backend_name -> alternativt
    - annars klassnamn
    """
    try:
        name_attr = getattr(backend, "name", None)
        if callable(name_attr):
            n = name_attr()
        elif isinstance(name_attr, str):
            n = name_attr
        else:
            n = getattr(backend, "backend_name", None)
        if not n:
            n = type(backend).__name__
        return str(n)
    except Exception:
        return type(backend).__name__
# -----------------------------------------------


# Minimal ‚Äúsampler‚Äù-adapter som fungerar oavsett Qiskit-version/back-end.
class MiniSampler:
    """Liten wrapper som ger .run(circuits, shots) -> list[dict(state->prob)]"""

    def __init__(self, backend, shots: int = 2048, seed_simulator: Optional[int] = None):
        self.backend = backend
        self.shots = shots
        self.seed_simulator = seed_simulator

    def _run_single(self, qc: "QuantumCircuit") -> Dict[str, float]:
        # s√§kerst√§ll m√§tningar finns
        if not qc.num_clbits or all([mop.operation.name != "measure" for mop in qc.data]):
            measured = qc.copy()
            measured.measure_all()
        else:
            measured = qc

        # Transpile f√∂r backend
        tqc = transpile(measured, self.backend)
        job = self.backend.run(tqc, shots=self.shots, seed_simulator=self.seed_simulator)
        result = job.result()
        counts = result.get_counts()
        # normalisera till sannolikheter
        total = sum(counts.values()) if counts else 1
        return {k: v / total for k, v in counts.items()}

    def run(self, circuits: List["QuantumCircuit"], shots: Optional[int] = None) -> List[Dict[str, float]]:
        out = []
        for qc in circuits:
            out.append(self._run_single(qc))
        return out


# ---------------------------
# Hj√§lpfunktioner (statistik, utskrift)
# ---------------------------

def bitstr_prob_top(probs: Dict[str, float]) -> Tuple[str, float]:
    if not probs:
        return "0", 0.0
    key = max(probs, key=lambda k: probs[k])
    return key, probs[key]


def z_expect_2q(probs: Dict[str, float]) -> float:
    # ‚ü®Z‚äóZ‚ü© = P(00)+P(11) - P(01) - P(10)
    return probs.get("00", 0.0) + probs.get("11", 0.0) - probs.get("01", 0.0) - probs.get("10", 0.0)


def bias_1q(probs: Dict[str, float], bit_index_from_right: int) -> float:
    # bias = P(bit=0) - P(bit=1)
    p0 = 0.0
    p1 = 0.0
    for b, p in probs.items():
        bit = b[::-1][bit_index_from_right]  # h√∂ger=LSB
        if bit == "0":
            p0 += p
        else:
            p1 += p
    return p0 - p1


def shannon_H_bits(probs: Dict[str, float]) -> float:
    H = 0.0
    for p in probs.values():
        if p > 0:
            H -= p * math.log2(p)
    return H


def uniformity_score(probs: Dict[str, float]) -> float:
    # 2^n m√∂jligheter; f√∂rdela mot uniform: sum(|p - 1/N|)/2 -> h√§r rapporterar vi 1 - (L1-avvikelse)
    # Detta blir ett snabbt, intuitivt ‚Äúhur close till uniform‚Äù.
    if not probs:
        return 0.0
    n = len(next(iter(probs)))  # l√§ngd p√• bitstr√§ng
    N = 2 ** n
    base = 1.0 / N
    l1 = 0.0
    for s in probspace(n):
        l1 += abs(probs.get(s, 0.0) - base)
    # normalisera, 0=helt olika, 1=helt uniform
    return max(0.0, 1.0 - 0.5 * l1)


def probspace(nbits: int) -> List[str]:
    return [format(i, f"0{nbits}b") for i in range(2 ** nbits)]


def pretty_json(d: dict) -> str:
    return json.dumps(d, ensure_ascii=False, indent=2, sort_keys=True)


def say(msg: str):
    print(msg, flush=True)


# ---------------------------
# 2-qubit QCDS ‚Äúkontroller‚Äù
# ---------------------------

def qc_truth_gradient() -> QuantumCircuit:
    # Skapar stark Z-korrelation (Bell-liknande 00/11)
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.measure([0, 1], [0, 1])
    return qc


def qc_amplitude_confirmation() -> QuantumCircuit:
    # L√§tt fas-koppling (CZ) fr√•n superposition -> m√§ter i Z-bas
    qc = QuantumCircuit(2, 2)
    qc.h([0, 1])
    qc.cz(0, 1)
    qc.measure([0, 1], [0, 1])
    return qc


def qc_conditional_enhancement() -> QuantumCircuit:
    # F√∂rst√§rk kombinationer d√§r b√•da √§r "lika" (00/11) via X, H, CX, H, X (en simpel proxy)
    qc = QuantumCircuit(2, 2)
    qc.h(0)
    qc.cx(0, 1)
    qc.h(0)
    qc.h(1)
    qc.measure([0, 1], [0, 1])
    return qc


def report_2q(name: str, probs: Dict[str, float], layman: bool):
    top, ptop = bitstr_prob_top(probs)
    expzz = z_expect_2q(probs)
    b0 = bias_1q(probs, 0)
    b1 = bias_1q(probs, 1)
    H = shannon_H_bits(probs)
    say(f"‚ñ∂Ô∏è {name} ‚Äî top: {top}")
    say(f"   probs: {pretty_json(probs)}")
    say(f"   QCDS ‚ü®Z‚äóZ‚ü©: {round(expzz, 4)} | bias(q0): {round(b0, 4)} | bias(q1): {round(b1, 4)} | H: {round(H, 4)}")
    if layman:
        if name.startswith("Truth Gradient"):
            say("\nüìò L√§ttf√∂rst√•elig f√∂rklaring (2 qubits):")
            say("‚Äî Truth Gradient (TG): m√§ter hur ofta bitarna √§r lika (00/11) mot olika (01/10).")
            say(f"  Resultat: h√∂gsta utfallet √§r {top} ({ptop:.1%}). "
                f"H√∂g ‚ü®Z‚äóZ‚ü©={round(expzz,3)} ‚áí stark samvariation.")
            say("  Lekman: ‚ÄúT√§nk tv√• lampor ‚Äì de t√§nds/sl√§cks oftare samtidigt √§n motsatt.‚Äù\n")
        elif name.startswith("Amplitude Confirmation"):
            say("\nüìò L√§ttf√∂rst√•elig f√∂rklaring (2 qubits):")
            say("‚Äî Amplitude Confirmation (AC): liten fas-interaktion (CZ), sedan l√§sning i Z-bas.")
            say(f"  Resultat: h√∂gsta utfallet √§r {top} ({ptop:.1%}). "
                f"‚ü®Z‚äóZ‚ü©‚âà{round(expzz,3)} ‚áí n√§ra neutral/√•terh√•llen korrelation.")
            say("  Lekman: ‚ÄúVi nyper systemet i fas ‚Äì utfallet blir ganska j√§mnt om allt √§r balanserat.‚Äù\n")
        elif name.startswith("Conditional Enhancement"):
            say("\nüìò L√§ttf√∂rst√•elig f√∂rklaring (2 qubits):")
            say("‚Äî Conditional Enhancement (CE): f√∂rst√§rker l√§gen d√§r b√•da bitar uppfyller ett villkor.")
            say(f"  Resultat: h√∂gsta utfallet √§r {top} ({ptop:.1%}). "
                f"‚ü®Z‚äóZ‚ü©={round(expzz,3)} ‚áí tydlig f√∂rst√§rkning.")
            say("  Lekman: ‚ÄúN√§r villkoret st√§mmer blir den kombinationen extra sann.‚Äù\n")


# ---------------------------
# 4-lager QCDS (symbolisk, 4 qubits)
# ---------------------------

@dataclass
class LayerConfig:
    # prop: "vilken bit fixas" p√• den h√§r niv√•n (symboliskt)
    prop: Dict[int, str]
    iters: int


def qc_4layer(prop: Dict[int, str], iters: int = 1) -> QuantumCircuit:
    """
    En enkel 4-qubits ‚Äúv√•g‚Äù-f√∂rst√§rkare.
    - prop = t.ex. {3:'0', 2:'0'} betyder att vi biasar q3,q2 mot 0.
    - iters = hur m√•nga repetitioner av en mild ‚Äòf√∂rst√§rkare‚Äô.
    """
    nq = 4
    qc = QuantumCircuit(nq, nq)
    # starta i superposition
    qc.h(range(nq))
    for _ in range(max(1, iters)):
        # villkors-f√∂rst√§rkning: CZ-kedja + X p√• specificerade noder
        for qb, want in prop.items():
            if want == "1":
                qc.x(qb)
        # enklare multi-CZ via kedja
        qc.cz(0, 1)
        qc.cz(1, 2)
        qc.cz(2, 3)
        for qb, want in prop.items():
            if want == "1":
                qc.x(qb)
        # spridning
        qc.h(range(nq))
        qc.cz(0, 3)
        qc.h(range(nq))
    qc.measure(range(nq), range(nq))
    return qc


def report_4l(stage: str, probs: Dict[str, float], layman: bool):
    n = len(next(iter(probs))) if probs else 4
    H = shannon_H_bits(probs)
    uni = uniformity_score(probs)
    top, ptop = bitstr_prob_top(probs)
    say(f"‚ñ∂Ô∏è QCDS_4L {stage} ‚Äî top: {top}  p_true‚âà{ptop:.4f}")
    say(f"   QCDS H({n} qubits): {round(H,4)} | uniformitet‚âà{round(uni,4)}")
    if layman:
        say("  Lekman: ‚ÄúVi k√∂r 4 ‚Äòniv√•er‚Äô som f√∂rst√§rker m√∂nster som h√§nger ihop. "
            "H√∂gre ‚ÄòH‚Äô och j√§mn ‚Äòuniformitet‚Äô ger oss robust signal utan att l√•sa fast en slump.‚Äù")


# ---------------------------
# Adaptiv Grover med roterande bitexkludering (4 bitars evidens)
# ---------------------------

def make_grover_oracle_4bit(target_bits: str, exclude_idx: int) -> QuantumCircuit:
    """
    Orakel markerar "sanning" f√∂r de inkluderade 3 av 4 bitarna.
    exclude_idx = vilken bit som *tas bort* ur indata-embeddningen denna g√•ng.
    """
    assert len(target_bits) == 4
    qc = QuantumCircuit(4)
    # X p√• de inkluderade bitar som ska vara '0' -> markera 000* osv
    for i, tb in enumerate(target_bits):
        if i == exclude_idx:
            continue  # hoppa √∂ver
        if tb == "0":
            qc.x(i)
    # enkel multi-Z via CZ-kedja som ‚Äúmarkering‚Äù
    qc.h(3)
    qc.ccx(0, 1, 2)  # grov proxy f√∂r "AND"
    qc.cz(2, 3)      # mark
    qc.ccx(0, 1, 2)  # uncompute
    qc.h(3)
    # √•terst√§ll X
    for i, tb in enumerate(target_bits):
        if i == exclude_idx:
            continue
        if tb == "0":
            qc.x(i)
    return qc


def grover_diffusion_4(nq: int = 4) -> QuantumCircuit:
    qc = QuantumCircuit(nq)
    qc.h(range(nq))
    qc.x(range(nq))
    qc.h(nq - 1)
    qc.mcx(list(range(nq - 1)), nq - 1)
    qc.h(nq - 1)
    qc.x(range(nq))
    qc.h(range(nq))
    return qc


def run_adaptive_grover_4bit(sampler: MiniSampler,
                              target_bits: str,
                              shots: int,
                              max_iters_to_try: int = 6,
                              rotate_exclusion: bool = True,
                              seed: Optional[int] = None) -> Dict[str, float]:
    """
    Adaptivt Grover-uppl√§gg:
      - Roterar exkluderad bit (om rotate_exclusion=True)
      - Testar 1..max_iters_to_try iterationer
      - V√§ljer b√§sta "p_true" (andel m√§tningar som matchar target_bits exakt)
    """
    if seed is not None:
        random.seed(seed)

    def p_true_of(probs: Dict[str, float]) -> float:
        return probs.get(target_bits, 0.0)

    best: Dict[str, float] = {}
    best_p = -1.0
    exclude_order = [0, 1, 2, 3] if rotate_exclusion else [None]
    for excl in exclude_order:
        for iters in range(1, max_iters_to_try + 1):
            # bygg Grover-cirkeln
            qc = QuantumCircuit(4, 4)
            qc.h(range(4))  # init
            # iters g√•nger: orakel (med exkluderad bit) + diffusion
            for _ in range(iters):
                oracle = make_grover_oracle_4bit(target_bits, excl if excl is not None else 0)
                qc.compose(oracle, qubits=range(4), inplace=True)
                qc.compose(grover_diffusion_4(4), qubits=range(4), inplace=True)
            qc.measure(range(4), range(4))
            probs = sampler.run([qc], shots=shots)[0]
            p = p_true_of(probs)
            if p > best_p:
                best_p = p
                best = probs
    return best


# ---------------------------
# BRCA2-region & variantgenerering
# ---------------------------

@dataclass
class Region:
    chrom: str
    start: int
    end: int


BRCA2_DEFAULT = {
    "GRCh38": Region(chrom="13", start=32315474, end=32400266),
    "GRCh37": Region(chrom="13", start=32889611, end=32973809),
}


def iter_synthetic_brca2_positions(region: Region,
                                   stride: int = 50,
                                   max_positions: int = 60,
                                   seed: Optional[int] = None) -> List[int]:
    if seed is not None:
        random.seed(seed)
    L = max(1, (region.end - region.start) // max(1, stride))
    L = min(L, max_positions)
    ps: List[int] = []
    if L == 1:
        return [region.start]
    step = max(1, (region.end - region.start) // L)
    for i in range(L):
        p = region.start + i * step + random.randint(0, min(step - 1, 30))
        if p <= region.end:
            ps.append(p)
    return sorted(set(ps))


# ---------------------------
# IBM-backend (frivillig)
# ---------------------------

def get_backend(mode: str, ibm_backend_name: Optional[str]):

    if mode == "aer":
        try:
            backend = Aer.get_backend("qasm_simulator")
            return backend, "qasm_simulator"
        except Exception as e:
            say(f"‚ö†Ô∏è Kunde inte f√• AER qasm_simulator ({e}), f√∂rs√∂ker BasicAer.")
            backend = Aer.get_backend("qasm_simulator")
            return backend, "qasm_simulator"

    # mode == "ibm"
    if not HAVE_RUNTIME:
        say("‚ö†Ô∏è IBM Runtime ej tillg√§nglig i denna milj√∂. Faller tillbaka till AER.")
        backend = Aer.get_backend("qasm_simulator")
        return backend, "qasm_simulator"

    try:
        svc = QiskitRuntimeService()
        name = ibm_backend_name or "ibm_brisbane"
        backend = svc.backend(name)
        return backend, name
    except Exception as e:
        say(f"‚ö†Ô∏è Kunde inte √∂ppna IBM-backend ({e}). Faller tillbaka till AER.")
        backend = Aer.get_backend("qasm_simulator")
        return backend, "qasm_simulator"


# ---------------------------
# K√∂rfl√∂den
# ---------------------------

def run_2q_controls(sampler: MiniSampler, layman: bool):
    # TG
    tg = qc_truth_gradient()
    tg_probs = sampler.run([tg])[0]
    report_2q("Truth Gradient @ backend", tg_probs, layman)

    # AC
    ac = qc_amplitude_confirmation()
    ac_probs = sampler.run([ac])[0]
    report_2q("Amplitude Confirmation @ backend", ac_probs, layman)

    # CE
    ce = qc_conditional_enhancement()
    ce_probs = sampler.run([ce])[0]
    report_2q("Conditional Enhancement @ backend", ce_probs, layman)

    return {"TG": tg_probs, "AC": ac_probs, "CE": ce_probs}


def run_4layer_sequence(sampler: MiniSampler,
                        shots: int,
                        iters_sched=(1, 1, 3, 5),
                        force_aer_4l: bool = False,
                        running_on_aer: bool = True,
                        layman: bool = True):
    def _run_stage(label: str, prop: Dict[int, str], iters: int):
        qc = qc_4layer(prop, iters)
        probs = sampler.run([qc], shots=shots)[0]
        report_4l(f"{label} (iters={iters}, prop={prop})", probs, layman)
        return probs

    say(f"‚ñ∂Ô∏è QCDS Hierarkisk 4-lager (backend={'aer' if running_on_aer else 'ibm'})")

    out = {}
    out["L1"] = _run_stage("L1", {3: "0"}, iters_sched[0])
    out["L2"] = _run_stage("L2", {3: "0", 2: "0"}, iters_sched[1])
    out["L3"] = _run_stage("L3", {3: "0", 2: "0", 1: "0"}, iters_sched[2])
    out["L4"] = _run_stage("L4", {3: "0", 2: "0", 1: "0", 0: "0"}, iters_sched[3])
    return out


def run_brca2_end2end(mode: str,
                      sampler_main: MiniSampler,
                      sampler_for_4l: MiniSampler,
                      genome: str,
                      region: Optional[str],
                      aer_max_variants: int,
                      ibm_max_variants: int,
                      iters_sched: Tuple[int, int, int, int],
                      shots: int,
                      layman: bool,
                      seed: Optional[int] = None) -> Dict:

    # Regionval
    if region:
        chrom, rest = region.split(":")
        start, end = map(int, rest.split("-"))
        reg = Region(chrom=chrom, start=start, end=end)
    else:
        reg = BRCA2_DEFAULT.get(genome, BRCA2_DEFAULT["GRCh38"])

    # Hur m√•nga varianter k√∂r vi?
    max_vars = aer_max_variants if mode == "aer" else ibm_max_variants
    pos_list = iter_synthetic_brca2_positions(reg, stride=50, max_positions=max_vars, seed=seed)

    say(f"üì¶ Dataset (syntetiskt): BRCA2 {genome} {reg.chrom}:{reg.start}-{reg.end}")
    say(f"   Antal ‚Äòvarianter‚Äô att k√∂ra: {len(pos_list)} (mode={mode}, shots={shots})")

    results = []
    for pos in pos_list:
        evs: List[str] = []
        target_bits = "0000"

        say(f"üéØ Variant {reg.chrom}:{pos}  target_bits={target_bits}  evs={evs}")
        # L1..L4 p√• AER-sampler (kan vara samma som huvud om mode=aer)
        for i, (label, prop, iters) in enumerate([
            ("L1", {3: "0"}, iters_sched[0]),
            ("L2", {3: "0", 2: "0"}, iters_sched[1]),
            ("L3", {3: "0", 2: "0", 1: "0"}, iters_sched[2]),
            ("L4", {3: "0", 2: "0", 1: "0", 0: "0"}, iters_sched[3]),
        ], start=1):
            qc = qc_4layer(prop, iters)
            probs = sampler_for_4l.run([qc], shots=shots)[0]
            top, ptop = bitstr_prob_top(probs)
            H = shannon_H_bits(probs)
            uni = uniformity_score(probs)
            be_name = backend_label(sampler_for_4l.backend)  # <-- robust
            say(f"‚ñ∂Ô∏è QCDS_4L {label} (iters={iters}, prop={prop}) ‚Äî backend: {be_name} ‚Äî top: {top}  p_true‚âà{ptop:.4f}")
            say(f"   QCDS H(4 qubits): {round(H,4)} | uniformitet‚âà{round(uni,4)}")

        # Adaptiv Grover med roterande exkludering
        probs_g = run_adaptive_grover_4bit(
            sampler=sampler_main,
            target_bits=target_bits,
            shots=shots,
            max_iters_to_try=6,
            rotate_exclusion=True,
            seed=seed
        )
        p_true = probs_g.get(target_bits, 0.0)
        say(f"   ‚Ü≥ Adaptiv Grover: b√§sta p_true‚âà{p_true:.4f}  (roterande bitexkludering)")

        results.append({
            "chrom": reg.chrom,
            "pos": pos,
            "genome": genome,
            "evs": evs,
            "target_bits": target_bits,
            "grover_probs": probs_g,
            "p_true": p_true
        })

    if layman:
        say("\nüß≠ L√§ttf√∂rst√•elig sammanfattning (BRCA2 end-to-end):")
        say(f"‚Ä¢ Region: {reg.chrom}:{reg.start}-{reg.end} ({genome})  |  k√∂rda punkter: {len(pos_list)}")
        say("‚Ä¢ Varje 4-bitars ‚Äòevidensm√∂nster‚Äô (h√§r 0000 som demo) betyder: varje ‚Äò1‚Äô skulle flagga att just "
            "den evidenstypen fanns (t.ex. PVS1 = loss-of-function).")
        say("‚Ä¢ QCDS 4-lager f√∂rst√§rker konsistenta m√∂nster √∂ver flera niv√•er f√∂r att ‚Äòl√•sa in‚Äô sannare svar, och "
            "Grover-delen hittar sanningen utan fix iteration ‚Äì den konvergerar sj√§lv n√§r signalen √§r stark nog.")

    return {
        "region": {"chrom": reg.chrom, "start": reg.start, "end": reg.end, "genome": genome},
        "results": results,
    }


# ---------------------------
# CLI
# ---------------------------

def parse_args():
    p = argparse.ArgumentParser(description="QCDS end-to-end (AER/IBM) med 2q-kontroller, 4L och adaptiv Grover.")
    p.add_argument("--mode", choices=["aer", "ibm"], default="aer", help="V√§lj simulator (aer) eller IBM (ibm).")
    p.add_argument("--genome", choices=["GRCh37", "GRCh38"], default="GRCh38", help="Genom-build.")
    p.add_argument("--region", type=str, default=None,
                   help="K√∂r √∂ver specifik region, t.ex. 13:32315474-32400266 (√∂verskuggar genome-default).")
    p.add_argument("--shots", type=int, default=2048, help="Antal shots.")
    p.add_argument("--seed", type=int, default=None, help="Fr√∂ f√∂r determinism i demo-sampling.")
    p.add_argument("--layman", action="store_true", help="Aktivera lekmannaf√∂rklaringar.")
    p.add_argument("--iters-sched", type=str, default="1,1,3,5",
                   help="Schema f√∂r 4L-iters som csv, t.ex. 1,1,3,5")
    p.add_argument("--aer-max-variants", type=int, default=60, help="M√•nga punkter i AER-l√§ge.")
    p.add_argument("--ibm-max-variants", type=int, default=5, help="F√• punkter i IBM-l√§ge (ut√∂kningsbart).")
    p.add_argument("--ibm-backend", type=str, default=None, help="IBM-backendnamn (om --mode ibm).")
    p.add_argument("--force-aer-4l", action="store_true",
                   help="K√∂r 4-lager-delen p√• AER √§ven om --mode ibm.")
    return p.parse_args()


def main():
    args = parse_args()
    iters_sched = tuple(int(x) for x in args.iters_sched.split(","))  # typ (1,1,3,5)
    assert len(iters_sched) == 4, "--iters-sched m√•ste ha fyra heltal, t.ex. 1,1,3,5"

    say(f"‚öôÔ∏è  QCDS k√∂rl√§ge: {args.mode}  |  4L_FORCE_AER={args.force_aer_4l}  |  LaymanExplain={args.layman}")
    if args.region:
        say(f"     Region override: {args.region}")
    else:
        reg = BRCA2_DEFAULT.get(args.genome, BRCA2_DEFAULT["GRCh38"])
        say(f"     Profil f√∂r BRCA2: {args.genome}  |  default-region {reg.chrom}:{reg.start}-{reg.end}  | "
            f"max_variants={'AER:'+str(args.aer_max_variants) if args.mode=='aer' else 'IBM:'+str(args.ibm_max_variants)}  "
            f"|  iters_sched={iters_sched}  |  shots={args.shots}")

    # Backend/sampler f√∂r huvudfl√∂det
    backend_main, backend_name = get_backend(args.mode, args.ibm_backend)
    sampler_main = MiniSampler(backend_main, shots=args.shots, seed_simulator=args.seed)

    # Om 4L ska tvingas till AER (√§ven i IBM-l√§ge)
    if args.force_aer_4l and args.mode == "ibm":
        be_4l = Aer.get_backend("qasm_simulator")
        sampler_4l = MiniSampler(be_4l, shots=args.shots, seed_simulator=args.seed)
        running_on_aer_for_4l = True
    else:
        sampler_4l = sampler_main
        running_on_aer_for_4l = backend_name.startswith("qasm")

    # 2-qubit kontroller
    say("üîé 2-qubit QCDS-kontroller init‚Ä¶")
    _ = run_2q_controls(sampler_main, layman=args.layman)

    # 4-lager
    _ = run_4layer_sequence(sampler=sampler_4l,
                            shots=args.shots,
                            iters_sched=iters_sched,
                            force_aer_4l=args.force_aer_4l,
                            running_on_aer=running_on_aer_for_4l,
                            layman=args.layman)

    # BRCA2 end-to-end
    end2end = run_brca2_end2end(mode=args.mode,
                                sampler_main=sampler_main,
                                sampler_for_4l=sampler_4l,
                                genome=args.genome,
                                region=args.region,
                                aer_max_variants=args.aer_max_variants,
                                ibm_max_variants=args.ibm_max_variants,
                                iters_sched=iters_sched,
                                shots=args.shots,
                                layman=args.layman,
                                seed=args.seed)

    # Spara resultat lokalt (f√∂r sp√•rbarhet i din milj√∂)
    outfile = f"QCDS_end2end_brca2_{args.genome.lower()}_{args.mode}.json"
    try:
        with open(outfile, "w", encoding="utf-8") as f:
            json.dump(end2end, f, ensure_ascii=False, indent=2)
        say(f"\nüíæ QCDS end-to-end: sparade {outfile}")
    except Exception as e:
        say(f"‚ö†Ô∏è Kunde inte spara {outfile}: {e}")

    if args.layman:
        say("\nüí° Varf√∂r detta uppl√§gg kan vara √∂verl√§gset i praktiken:")
        say("‚Ä¢ QCDS-orakel + Grover anv√§nder **alla kvantbitar som vittnen**, men plockar bort **en bit i taget** "
            "(roterande exkludering). D√• tvingas varje k√∂rning ‚Äòbevisa‚Äô sanningen utan att kunna f√∂rlita sig p√• hela "
            "inmatningen. N√§r resultaten sedan sammanfogas f√•r du en **konsensus** som √§r robust mot brus och bias.")
        say("‚Ä¢ Grover √§r **adaptiv** h√§r: vi best√§mmer inte i f√∂rv√§g hur m√•nga iterationer som beh√∂vs. Ist√§llet l√•ter "
            "vi sanningen ‚Äòsegla upp‚Äô och v√§ljer den iteration som gav b√§st signal (p_true). Det **minskar risken** "
            "att √∂ver- eller under-amplifiera (som annars kan tv√§tta bort signal).")
        say("‚Ä¢ 4L-v√•gen fungerar som en **hierarkisk st√∂td√§mpare** som f√∂rst√§rker **konsekventa** m√∂nster och d√§mpar "
            "spret ‚Äì och d√§rf√∂r kan du k√∂ra AER √∂ver hela BRCA2 (massivt) och IBM √∂ver mindre batchar men f√• "
            "j√§mf√∂rbara, stabila sammanfattningar.")

if __name__ == "__main__":
    main()
